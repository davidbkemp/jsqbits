<!DOCTYPE html>
<html>
<head>
    <title>jsqbits User Manual</title>
    <link rel="stylesheet" type="text/css" href="jsqbitsManual.css" />
    <script src="jquery-1.7.1.min.js"></script>
    <script src="../src/js/jsqbits.js"></script>
    <script src="jsqbitsManual.js"></script>
</head>
<body>
<p id="topErrorMessage" class="error" style="display: none;">
    Automatic error checking of code samples has picked up some errors (highlighted in red).
</p>
<p id="topWarningMessage" class="warning">
    Performing automatic error checking of code samples.
    If you can still see this message, then you probably have JavaScript disabled.
</p>
<h1>jsqbits User Manual</h1>

<p id='tableOfContents'>
 Function list:
</p>

<p>
    <a href="http://jsqbits.org">jsqbits</a> is a simple JavaScript library for quantum computation simulation.
    To use it, you can down load and use the JavaScript library from the
    <a href="https://github.com/davidbkemp/jsqbits/downloads">jsqbits github repository</a>,
    or you can try the online
    <a href="http://davidbkemp.github.com/jsqbits/jsqbitsRunner.html">jsqbits runner</a>.
    You can use it to implement quantum algorithms using JavaScript like this:
</p>

<code class="block">
jsqbits('|01>')
    .hadamard(jsqbits.ALL)
    .cnot(1, 0)
    .hadamard(jsqbits.ALL)
    .measure(1)
    .result
</code>

<div class='section'  id='jsqbits'>
    <h2>jsqbits.QState</h2>
    <ul class="code index">
        <li>jsqbits(bitString)</li>
        <li>QState(numBits, amplitudes)</li>
    </ul>
    <p>
        QState is used to encapsulate the state of a quantum computer.
        You create one by either calling its constructor or using the convenient <code>jsqbits(bitString)</code> function.
    </p>
    <p>
        The jsqbits function takes a string zeros and ones representing the state of its qbits.
        The string may optionally be a "ket" in the "bra-ket" notation.
    </p>
    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="jsqbits1">jsqbits("0101")</td>
            <td>creates a 4 qbit QState in the simple basis state of</td>
            <td class="code" data-sampleref="jsqbits1">1 |0101></td>
        </tr>
        <tr>
            <td class="code" id="jsqbits2">jsqbits("|0101>")</td>
            <td>also creates a 4 qbit QState of</td>
            <td class="code" data-sampleref="jsqbits2">1 |0101></td>
        </tr>
        </tbody>
    </table>

    <p>
        Note the "1" out the front of <code>1 |0101></code> indicates that the amplitude of  <code>|0101></code> is 1.
    </p>

    <p>
        If you want your initial state to be in a super-position of states, then you can use the QState constructor directly,
        passing it the number of qbits, and a (sparse) array of complex number amplitudes.  For example
    </p>


    <code class="block" id="QState">
var a = []; a[0] = a[1] = a[4] = a[5] = jsqbits.complex(0.5, 0);
new jsqbits.QState(4, a)
    </code>
    <p>creates the following 4 qbit QState:</p>
    <code class="block"  data-sampleref="QState">
0.5 |0000> + 0.5 |0001> + 0.5 |0100> + 0.5 |0101>
    </code>

    <p>
        WARNING: Currently, instead of copying the supplied amplitude array, a reference to it is used,
        and so any subsequent modifications will affect the QState object.
    </p>
</div>

<div class='section' id='singleQbitOperators'>
    <ul class="code index">
        <li>x(targetBits)</li>
        <h2>Single qbit operators</h2>
        <li>y(targetBits)</li>
        <li>z(targetBits)</li>
        <li>hadamard(targetBits)</li>
        <li>not(targetBits)</li>
        <li>rotateX(targetBits, angle)</li>
        <li>rotateY(targetBits, angle)</li>
        <li>rotateZ(targetBits, angle)</li>
    </ul>
    <p>
        A number of operators operate on a single qbit (the Pauli operators and the Hadamard gate).
        For these, you must specify the index bit to be operated on, with the right most bit being bit 0,
        and the left most bit being bit n-1 for an n bit state.
        As a convenience, you can also specify a range of bits using an object with "from" and "to" attributes,
        and the operator will be applied to each of the bits in that range (inclusive).
        The constant <code>jsqbits.ALL</code> can be used to apply the operator to all the bits.
        For most operators (except where indicated), you may also use an array of bit indexes.
    </p>

    <p>
        Here are some examples using the Pauli X operator.
    </p>

    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="single1">jsqbits("|0000>").x(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="single1">1 |0001></td>
        </tr>
        <tr>
            <td class="code" id="single2">jsqbits("|0000>").x({from: 0, to: 2})</td>
            <td>gives</td>
            <td class="code" data-sampleref="single2">1 |0111></td>
        </tr>
        <tr>
            <td class="code" id="single3">jsqbits("|0000>").x(jsqbits.ALL)</td>
            <td>gives</td>
            <td class="code" data-sampleref="single3">1 |1111></td>
        </tr>
        <tr>
            <td class="code" id="single4">jsqbits("|0000>").x([0,2])</td>
            <td>gives</td>
            <td class="code" data-sampleref="single4">1 |0101></td>
        </tr>
        </tbody>
    </table>

    <p>
        All qbit manipulations return a new QState and leave the original one untouched.
        Consider the following code:
    </p>

    <code class="block" id='immutableExample'>
var state1 = jsqbits('|00>');
var state2 = state1.x(1);
"state2 is " + state2 + " but state1 is still " + state1
    </code>

    <p>
        This results in
        "<span class="code" data-sampleref="immutableExample">state2 is 1 |10> but state1 is still 1 |00></span>"
    </p>

    <p>
        There are single bit operators for the Pauli operators X, Y, and Z.
        These can be invoked as x(), y(), z(), or as X(), Y(), or Z().
        There is also a hadamard() function.
        There is a "not" function, which is just an alias for X.
    </p>

    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="x0">jsqbits("|00>").x(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="x0">1 |01></td>
        </tr>
        <tr>
            <td class="code" id="x1">jsqbits("|01>").x(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="x1">1 |00></td>
        </tr>
        <tr>
            <td class="code" id="y0">jsqbits("|00>").y(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="y0">i |01></td>
        </tr>
        <tr>
            <td class="code" id="y1">jsqbits("|01>").y(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="y1">-i |00></td>
        </tr>
        <tr>
            <td class="code" id="z0">jsqbits("|00>").z(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="z0">1 |00></td>
        </tr>
        <tr>
            <td class="code" id="z1">jsqbits("|01>").z(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="z1">-1 |01></td>
        </tr>
            <td class="code" id="not0">jsqbits("|00>").not(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="not0">1 |01></td>
        </tr>
        <tr>
            <td class="code" id="not1">jsqbits("|01>").not(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="not1">1 |00></td>
        </tr>
        </tr>
            <td class="code" id="hadamard0">jsqbits("|00>").hadamard(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="hadamard0">0.7071 |00> + 0.7071 |01></td>
        </tr>
        <tr>
            <td class="code" id="hadamard1">jsqbits("|01>").hadamard(0)</td>
            <td>gives</td>
            <td class="code" data-sampleref="hadamard1">0.7071 |00> - 0.7071 |01></td>
        </tr>
        </tbody>
    </table>

    <p>
    Other single qbit operators are those that rotate around the X, Y, and Z axis of the Bloch sphere.
    These take an angle and apply the operation
    e<sup>-i&theta;X/2</sup>,
    e<sup>-i&theta;Y/2</sup> or
    e<sup>-i&theta;Z/2</sup>.
    </p>

    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="rotateX0">jsqbits("|00>").rotateX(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateX0">0.7071 |00> - 0.7071i |01></td>
        </tr>
        <tr>
            <td class="code" id="rotateX1">jsqbits("|01>").rotateX(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateX1">-0.7071i |00> + 0.7071 |01></td>
        </tr>
        <tr>
            <td class="code" id="rotateY0">jsqbits("|00>").rotateY(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateY0">0.7071 |00> + 0.7071 |01></td>
        </tr>
        <tr>
            <td class="code" id="rotateY1">jsqbits("|01>").rotateY(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateY1">-0.7071 |00> + 0.7071 |01></td>
        </tr>
        <tr>
            <td class="code" id="rotateZ0">jsqbits("|00>").rotateZ(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateZ0">0.7071-0.7071i |00></td>
        </tr>
        <tr>
            <td class="code" id="rotateZ1">jsqbits("|01>").rotateZ(0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="rotateZ1">0.7071+0.7071i |01></td>
        </tr>
        </tbody>
    </table>
</div>

<div class='section' id='ControlledOperations'>
    <h2>Controlled operations</h2>
    <ul class="code index">
        <li>controlledX(controlBits, targetBits)</li>
        <li>controlledY(controlBits, targetBits)</li>
        <li>controlledZ(controlBits, targetBits)</li>
        <li>controlledHadamard(controlBits, targetBits)</li>
        <li>cnot(controlBits, targetBits)</li>
        <li>controlledXRotation(controlBits, targetBits, angle)</li>
        <li>controlledYRotation(controlBits, targetBits, angle)</li>
        <li>controlledZRotation(controlBits, targetBits, angle)</li>
    </ul>
    <p>
        There are controlled versions of all the single qbit operators.
        For these you must specify control bits as well as target bits.
        As with the target bits, the control bits may be a single bit index,
        a range of bits using an object with "from" and "to" attributes,
        or an array of bit indexes.
        The operation is only performed when all of the control bits are ones.
        Note that the control and target bits must not have any bits in common.
    </p>

    <p>
        Here are some examples using the Pauli X operator.
    </p>

    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="control1">jsqbits("|0000>").controlledX(2, 0)</td>
            <td>leaves the state unchanged:</td>
            <td class="code" data-sampleref="control1">1 |0000></td>
        </tr>
        <tr>
            <td class="code" id="control2">jsqbits("|0100>").controlledX(2, 0)</td>
            <td>flips bit zero to give:</td>
            <td class="code" data-sampleref="control2">1 |0101></td>
        </tr>
        <tr>
            <td class="code" id="control3">jsqbits("|0010>").controlledX([1,3], 0)</td>
            <td>leaves the state unchanged:</td>
            <td class="code" data-sampleref="control3">1 |0010></td>
        </tr>
        <tr>
            <td class="code" id="control4">jsqbits("|1010>").controlledX([1,3], 0)</td>
            <td>flips bit zero to give:</td>
            <td class="code" data-sampleref="control4">1 |1011></td>
        </tr>
        <tr>
            <td class="code" id="control5">jsqbits("|1010>").controlledX({from:1, to: 3}, 0)</td>
            <td>leaves the state unchanged:</td>
            <td class="code" data-sampleref="control5">1 |1010></td>
        </tr>
        <tr>
            <td class="code" id="control6">jsqbits("|1110>").controlledX({from:1, to: 3}, 0)</td>
            <td>flips bit zero to give:</td>
            <td class="code" data-sampleref="control6">1 |1111></td>
        </tr>
        <tr>
            <td class="code" id="control7">jsqbits("|1010>").controlledX([2,3], [0,1])</td>
            <td>leaves the state unchanged:</td>
            <td class="code" data-sampleref="control7">1 |1010></td>
        </tr>
        <tr>
            <td class="code" id="control8">jsqbits("|1110>").controlledX([2,3], [0,1])</td>
            <td>flips bit zero and one give:</td>
            <td class="code" data-sampleref="control8">1 |1101></td>
        </tr>
        </tbody>
    </table>

    <p>
        In addition to controlledX(), there are controlledY(), controlledZ(), and controlledHadamard() functions.
        The function cnot() is an alias for controlledX().
        There are also controlledXRotation(), controlledYRotation(), and controlledZRotation() functions.
    </p>
    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="controlledXRotation">jsqbits("|010>").controlledXRotation(1, 0, Math.PI/2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="controlledXRotation">0.7071 |010> - 0.7071i |011></td>
        </tr>
        </tbody>
    </table>
</div>

<div class='section' id='measurement'>
    <h2>Measurement</h2>
    <ul class="code index">
        <li>measure(targetBits)</li>
    </ul>
    <p>
        The measurement operator is intended to simulate the act of measuring one or more of the qbits.
        You may specify a single bit index, a range of bits using an object with "from" and "to" attributes,
        or the constant <code>jsqbits.ALL</code>.
        Note that currently you cannot supply an array of bit indexes.
        As with all QState functions, the meaurement() function does not actually modify the object,
        but instead returns an object with a "result" field containing the integer value of the result,
        and a "newState" field containing the new quantum state (as a new QState object).
    </p>
    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="measurement1">jsqbits("|0110>").measure(2)</td>
            <td>gives</td>
            <td class="code" data-sampleref="measurement1">{result: 1, newState: 1 |0110>}</td>
        </tr>
        <tr>
            <td class="code" id="measurement2">jsqbits("|0110>").measure({from:1, to: 3})</td>
            <td>gives</td>
            <td class="code" data-sampleref="measurement2">{result: 3, newState: 1 |0110>}</td>
        </tr>
        <tr>
            <td class="code" id="measurement3">jsqbits("|0110>").measure(jsqbits.ALL)</td>
            <td>gives</td>
            <td class="code" data-sampleref="measurement3">{result: 6, newState: 1 |0110>}</td>
        </tr>
        <tr>
            <td class="code" id="measurement4">jsqbits("|00>").hadamard(0).measure(1)</td>
            <td>gives</td>
            <td class="code" data-sampleref="measurement4">{result: 0, newState: 0.7071 |00> + 0.7071 |01>}</td>
        </tr>
        </tbody>
    </table>

    <p>
        The random number generator used during measurement is exposed as
        a function called "random" on instances of QState and hence may be over-ridden
        by replacing the prototype function or replacing it on individual objects.
        Here is how you can get measurements to always choose the first basis state with
        a non-zero amplitude:
    </p>
    <code class="block" id="random">
jsqbits.QState.prototype.random = function() {return 0;};
jsqbits("|100>").hadamard([0,1]).measure(0)
    </code>
    <p>
        always results in
        <span class="code" data-sampleref="random">{result: 0, newState: 0.7071 |100> + 0.7071 |110>}</span>
    </p>
</div>

<div class='section' id='toffoli'>
    <h2>Toffoli</h2>
    <ul class="code index">
        <li>toffoli(controlBit, controlBit, ..., targetBit)</li>
    </ul>
    <p>
        Given that the controlledX() operator can cake multiple control bits,
        a separate Toffoli operator is redundant,
        but has been added for the sake of convenience.
        It takes one or more control bit indexes as separate arguments,
        followed by a target bit index (which actually can instead be a bit range or array).
    </p>

    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="Toffoli1">jsqbits("|0001>").toffoli(0, 2, 3)</td>
            <td>leaves the state unchanged:</td>
            <td class="code" data-sampleref="Toffoli1">1 |0001></td>
        </tr>
        <tr>
            <td class="code" id="Toffoli2">jsqbits("|0101>").toffoli(0, 2, 3)</td>
            <td>flips bit three to give:</td>
            <td class="code" data-sampleref="Toffoli2">1 |1101></td>
        </tr>
        </tbody>
    </table>
</div>

<div class='section' id='applyFunction'>
    <h2>applyFunction</h2>
    <ul class="code index">
        <li>applyFunction(inputBits, targetBits, functionToApply)</li>
    </ul>
    <p>
        The <code>applyFunction</code> method takes
        an input bit specification,
        an output bit specification,
        and a function to apply.
        The input and output bit specifications must either be single bit indexes
        or bit ranges using "from" and "to" attributes.
        <em>Note that currently they cannot be arrays.</em>
        The value of the bits specified by the input bit index (or range)
        is fed to the function, and the result is
        applied to the output bit (or range).
        For example,
    </p>
    <code class="block" id="applyFunctionSample">
jsqbits("|10110>")
    .applyFunction(
        {from:3, to:4},
        {from:0, to:2},
        function(x){return x+1;})
    </code>
    <p>
        In the example, the function is passed the top two bits (ie, the value 2) and so it returns 3.
        This is to be applied to bits 0 to 2 and so the function's return value is
        treated as the bit string "011" and xor'ed with the bottom three bits to give:
        <span class="code" data-sampleref="applyFunctionSample">1 |10101></span>
    </p>
</div>

<div class='section' id='amplitude'>
    <h2>amplitude</h2>
    <ul class="code index">
        <li>amplitude(basisState)</li>
    </ul>
    <p>
        The <code>amplitude</code> method can return the value of a specific amplitude.
    </p>
</div>

<div class='section' id='roundToZero'>
    <h2 class='index'>jsqbits.roundToZero</h2>
    <p>
        Note that, while the QState values are displayed to four decimal places, they are maintained to
        the maximum precision provided by the JavaScript implementation of floating point numbers,
        with the exception that numbers very close to zero are rounded off to zero.
        The value used for determining this rounding to zero is the variable <code>jsqbits.roundToZero</code>.
    </p>
</div>

<div class='section' id='complex'>
    <h2 class="index">Complex</h2>
    <p>
        Given that the amplitudes of a quantum state are complex numbers,
        jsqbits has a Complex class.  The easiest way to create a complex number is using
        the method: <code>jsqbits.complex(real, imaginary)</code>
    </p>
    <table class="samples">
        <tbody>
        <tr>
            <td class="code" id="complexSample">jsqbits.complex(3, 4)</td>
            <td>=</td>
            <td class="code" data-sampleref="complexSample">3+4i</td>
        </tr>
        <tr>
            <td class="code" id="complex-add">jsqbits.complex(3, 4).add(jsqbits.complex(10, 20))</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-add">13+24i</td>
        </tr>
        <tr>
            <td class="code" id="complex-addreal">jsqbits.complex(3, 4).add(7)</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-addreal">10+4i</td>
        </tr>
        <tr>
            <td class="code" id="complex-subtract">jsqbits.complex(3, 4).subtract(jsqbits.complex(10, 20))</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-subtract">-7-16i</td>
        </tr>
        <tr>
            <td class="code" id="complex-subtractreal">jsqbits.complex(3, 4).subtract(7)</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-subtractreal">-4+4i</td>
        </tr>
        <tr>
            <td class="code" id="complex-multiply">jsqbits.complex(3, 4).multiply(jsqbits.complex(10, 20))</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-multiply">-50+100i</td>
        </tr>
        <tr>
            <td class="code" id="complex-multiplyreal">jsqbits.complex(3, 4).multiply(10)</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-multiplyreal">30+40i</td>
        </tr>
        <tr>
            <td class="code" id="complex-negate">jsqbits.complex(3, 4).negate()</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-negate">-3-4i</td>
        </tr>
        <tr>
            <td class="code" id="complex-magnitude">jsqbits.complex(3, 4).magnitude()</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-magnitude">5</td>
        </tr>
        <tr>
            <td class="code" id="complex-format">jsqbits.complex(-1.235959, 3.423523).format({decimalPlaces: 3})</td>
            <td>=</td>
            <td class="code" data-sampleref="complex-format">-1.236+3.424i</td>
        </tr>
        </tbody>
    </table>
</div>
<p>
<a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">jsqbits User Manual</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/davidbkemp" property="cc:attributionName" rel="cc:attributionURL">David Kemp</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.
</p>
</body>
</html>