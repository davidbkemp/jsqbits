/*
 * Shor's factoring algorithm.
 * See https://cs.uwaterloo.ca/~watrous/lecture-notes/519/11.pdf
 */

function computeOrder(a, n, numOutBits, callback) {
    var numInBits = 2 * numOutBits;
    var inputRange = Math.pow(2,numInBits);
    var outputRange = Math.pow(2,numOutBits);
    var accuracyRequiredForContinuedFraction = 1/(2 * outputRange * outputRange);
    var outBits = {from: 0, to: numOutBits - 1};
    var inputBits = {from: numOutBits, to: numOutBits + numInBits - 1};
    var attempts = 0;
    var successes = 0;
    var bestSoFar = 1;
    var f = function(x) { return jsqbitsmath.powerMod(a, x, n); }
    var f0 = f(0);

    function continueFindingPeriod() {
        if (successes === numOutBits || attempts === 2 * numOutBits) {
            print("Giving up tring to find rank of " + a);
            callback("failed");
            return;
        }

        var qstate = new jsqbits.QState(numInBits + numOutBits).hadamard(inputBits);
        qstate = qstate.applyFunction(inputBits, outBits, f);
        // We do not need to measure the outBits, but it does speed up the simulation.
        qstate = qstate.measure(outBits).newState;
        var result = qstate.qft(inputBits).measure(inputBits).result;
        
        var continuedFraction = jsqbitsmath.continuedFraction(result/inputRange, accuracyRequiredForContinuedFraction);
        var candidate = continuedFraction.denominator;
        print("Candidate order: " + candidate);
        // Reduce the chances of getting the wrong answer by ignoring obviously wrong results!
        if (candidate <= outputRange && candidate > 1) {
            if(f(candidate) === f0) {
                callback(candidate);
                return;
            }
            var lcm = jsqbitsmath.lcm(candidate, bestSoFar)
            if (lcm <= outputRange) {
                successes++;
                bestSoFar = lcm;
                if (f(bestSoFar) === f0) {
                    callback(bestSoFar);
                    return;
                }
            }
        }
        attempts++;
        print("Least common multiple: " + bestSoFar + ". Attempts: " + attempts + ". Good candidates: " + successes);
        // Yield control to give the browser a chance to print to the console.
        setTimeout(continueFindingPeriod, 50);
    }

    continueFindingPeriod();
}

function factor(n, callback) {

    var attempt = 0;
    var numOutBits = Math.ceil(Math.log(n)/Math.log(2));
    print("Number of input bits: " + numOutBits);

    function attemptFactor() {
        if (attempt++ === 8) {
            callback("failed");
            return;
        }
        var a = 2 + Math.floor(Math.random() * (n - 2));
        print("Randomly choose " + a);
        var d = jsqbitsmath.gcd(a, n);
        if(d > 1) {
            print("Lucky guess");
            callback(d);
            return;
        }

        computeOrder(a, n, numOutBits, function(r) {
            print("Order (mod " + n + ") of " + a + " is " + r);
            if (r !== "failed" && r % 2 === 0) {
                var x = jsqbitsmath.powerMod(a, r/2, n) - 1;
                var d = jsqbitsmath.gcd(x, n);
                print("x = " + x + ", d = " + d);
                if(d > 1) {
                    if (n % d === 0) {
                        callback(d);
                        return;
                    }
                }
            }
            // Yield control to give the browser a chance to print to the console.
            setTimeout(function(){attemptFactor();}, 30)
        });
    }

    if (n % 2 === 0) {
        print("Is even.  No need for any quantum computing!")
        callback(2);
        return;
    }

    var powerFactor = jsqbitsmath.powerFactor(n);
    if (powerFactor > 1) {
        print("Is a power factor.  No need for anything quantum!")
        callback(powerFactor);
        return;
    }

    attemptFactor();
}

var n = prompt("Enter a product of two distinct primes: ", 35);

var startTime = new Date();
factor(n, function(result) {
    print("One of the factors of " + n + " is " + result);
    print("Time taken in seconds: " + ((new Date().getTime()) - startTime.getTime()) / 1000);
});